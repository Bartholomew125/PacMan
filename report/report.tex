%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Define Article %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Using Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{titling}
\usepackage[danish]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{empheq}
\usepackage{mdframed}
\usepackage{booktabs}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage{psfrag}
\usepackage{pgfplots}
\usepackage{bm}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{svg}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Other Settings

%%%%%%%%%%%%%%%%%%%%%%%%%% Page Setting %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\geometry{a4paper, bottom=3cm}


%%%%%%%%%%%%%%%%%%%%%%%%%% Styles %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usemintedstyle{borland}
%%%%%%%%%%%%%%%%%%%%%%%%%% Define some useful colors %%%%%%%%%%%%%%%%%%%%%%%%%%
\definecolor{ocre}{RGB}{243,102,25}
\definecolor{mygray}{RGB}{243,243,244}
\definecolor{deepGreen}{RGB}{26,111,0}
\definecolor{shallowGreen}{RGB}{235,255,255}
\definecolor{deepBlue}{RGB}{61,124,222}
\definecolor{shallowBlue}{RGB}{235,249,255}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%% Define codecomment command %%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\code}[1]{\small\mintinline[xleftmargin=2em, xrightmargin=2em,
breaklines]{java}{#1}}
\newcommand{\class}[1]{\textcolor{BlueViolet}{\small\mintinline[xleftmargin=2em,
xrightmargin=2em, breaklines]{java}{#1}}}
\newcommand{\snippet}[3]{\inputminted[firstline=#1,lastline=#2,linenos,
xleftmargin=1.5em, breaklines]{java}{#3}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%% Define an orangebox command %%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\orangebox[1]{\fcolorbox{ocre}{mygray}{\hspace{1em}#1\hspace{1em}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%% English Environments %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheoremstyle{mytheoremstyle}{3pt}{3pt}{\normalfont}{0cm}{\rmfamily\bfseries}{}{1em}{{\color{black}\thmname{#1}~\thmnumber{#2}}\thmnote{\,--\,#3}}
\newtheoremstyle{myproblemstyle}{3pt}{3pt}{\normalfont}{0cm}{\rmfamily\bfseries}{}{1em}{{\color{black}\thmname{#1}~\thmnumber{#2}}\thmnote{\,--\,#3}}
\theoremstyle{mytheoremstyle}
\newmdtheoremenv[linewidth=1pt,backgroundcolor=shallowGreen,linecolor=deepGreen,leftmargin=0pt,innerleftmargin=20pt,innerrightmargin=20pt,]{theorem}{Theorem}[section]
\theoremstyle{mytheoremstyle}
\newmdtheoremenv[linewidth=1pt,backgroundcolor=shallowBlue,linecolor=deepBlue,leftmargin=0pt,innerleftmargin=20pt,innerrightmargin=20pt,]{definition}{Definition}[section]
\theoremstyle{myproblemstyle}
\newmdtheoremenv[linecolor=black,leftmargin=0pt,innerleftmargin=10pt,innerrightmargin=10pt,]{problem}{Problem}[section]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Plotting Settings %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepgfplotslibrary{colorbrewer}
\pgfplotsset{width=8cm,compat=1.9}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Title & Author %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\textbf{Objektorienteret Programmering Projekt PacMan}}
\author{Andreas K. L. \quad Aske W. F. \quad Magnus R. K.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\pagenumbering{gobble}
\begin{titlepage}
    \maketitle
    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=0.77\textwidth]{figures/FrontPageImage.png}
        \end{center}
    \end{figure}
\end{titlepage}
    \clearpage
    \newpage
    \pagenumbering{arabic}
    \setcounter{page}{1}

    % Only footer, no header
    \pagestyle{fancy}
    % \fancyhf{} 
    \fancyfoot[C]{\textbf{\thepage}\ of \pageref{LastPage}}
    % \renewcommand{\headrulewidth}{0pt}  

    \tableofcontents
    \newpage
\section{Projektbeskrivelse}\label{sec:Beskrivelse} % (fold)

Til fordel for at sikre en så tro kopi til orignalen som overhovedet muligt, er
dette projekts hovedformål, at udvilke spilfunktionalitet mht.
kravsspecifikationen. 

Eventuelle afvigelser fra kravsspecifikationen ses dokumenteret/diskuteret i det
følgende.
% \begin{itemize}
%   \item Antag, at læseren af jeres rapport har læst kravsspecifikationen fra
%   projektbeskrivelsen i slutningen af dette dokument, og undlad at gentage
%   unødvendige detaljer derfra.
%   \item Formålet med denne sektion er at dokumentere eventuelle afvigelser fra
%   kravsspecifikationen.
%   \item Har I, for eksempel, gjort jer forsimplende antagelser ift.
%   specifikationen? Eller tolket eventuelle tvetydigheder i specifikationen?
%   Tilføjet nye krav? Beskriv hvilke og hvordan I evt. har tolket
%   specifikationen.
%   \item Hold det kort, især hvis I har få afvigelser.
% \end{itemize}
\newpage
% section Beskrivelse (end)

\section{design}\label{sec:design} % (fold)

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.95\textwidth]{figures/UML-diagram.png}
    \end{center}
    \caption{}
    \label{UML-diagram}
\end{figure}

Projektets design følger \textit{MVC} (Model-View-Controller) modellen. Det
vil sige at vores \textit{Model} repræsenterer hvordan PacMan spillet er bygget
op med spøgelser, væge, piller osv. Så har vi vores \textit{Controller} som står
for alt logikken med hvordan ting skal kolliderer og bevæge sig, og hvornår de
forskellige stadier af spillet sker. Til sidst har vi vores \textit{View} som
står for at vise spillet, med alle billederne og animationerne, samt score tekst
og liv osv.

Designet kan ses i vores \textit{UML}-diagram, hvor man kan se vi har opdelt
koden i de tre dele fra \textit{MVC} modellen, samt en \textit{main} fil til at
starte spillet, og initialiserer de andre klasser.

Vi har designet alt vores kode med fokus på \textit{indkapslingsprincippet}.
Alle felter i klasser er private, og har kun \textit{getters} og
\textit{setters} der hvor det er nødvendigt. Vi har også overholdt \textit{DRY}
princippet, ved at samle ens opførsel i fælles \textit{superklasser}.


\subsection{Model}\label{sub:Model} % (fold)
\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.95\textwidth]{figures/UML-diagram-model.png}
    \end{center}
    \caption{UML-diagram til \textit{Model} delen af projektet.}
    \label{UML-diagram-Model}
\end{figure}

I \textit{Model} (se \autoref{UML-diagram-Model}) har vi lavet et abstrakt klasse der
hedder \class{Moveable}, som er en abstrakt enhed der kan bevæge sig. Dette
tillader os at \textit{nedarve} fra den når vi skal lave ting der skal bevæge
sig som \class{Ghost} og \class{PacMan}. Ud over dette er \class{Ghost} også en
abstrakt klasse, så vi kan udvide de enkelte spøgelser fra den. Udover
\class{Moveable} klasse, har vi også en klasse, \class{Pos2D}, til at
beskrive positioner som ikke skal kunne bevæge sige. Fra denne klasse kan vi så
nedarve klasser som \class{Pill} og \class{Wall}, da de bare er positioner, men vi
godt vil kunne skelne imellem dem. På denne måde benytter vi
\textit{klasseafhængighedsprincippet} til at simplificerer koden, og gøre det
nemmere at udvide med nye features.
Alle disse afhængigheder samt nedarvelser, kan ses på ovenstående billede (se \autoref{UML-diagram-Model}).
% subsection Model (end)


\subsection{View}\label{sub:View} % (fold)
\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.95\textwidth]{figures/UML-diagram-view.png}
    \end{center}
    \caption{UML-diagram til \textit{View} delen af projektet.}
    \label{UML-diagram-view}
\end{figure}
I \textit{View} (se \autoref{UML-diagram-view}) har vi benyttet en
\textit{grænseflade} ved navn \class{View} som specificere hvilke metoder et
\textit{View} skal have. Så har vi lavet en abstrakt klasse \class{AbstractView},
som implementerer dette interface. Vi nedarver på denne måde fra det abstrakte
\textit{View} hver gang vi laver et nyt \textit{View} som står for at vise noget
andet. Så kan vi lave specifikke views som står for at tegne kun én slags ting,
f.eks. \class{PacManView}. På denne måde benytter vi princippet om et enkelt
ansvar, svarende til \textit{Single Responsibility Principle} eller \textit{SRP}.
% subsection View (end)

\subsection{Controller}\label{sub:Controller} % (fold)
\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.95\textwidth]{figures/UML-diagram-controller.png}
    \end{center}
    \caption{UML-diagram til \textit{Controller} delen af projektet.}
    \label{UML-diagram-controller}
\end{figure}

Til \textit{Controller} (se \autoref{UML-diagram-controller}) har vi også lavet
en grænseflade, for at specificerer hvad en "Controller" gør. Derefter har vi
lavet controllers til at styre henholdsvis PacMan, spøgelser og de forskellige
stadier af spillet. Med dette har vi lavet en \class{MainController} som
bestemmer hvornår alle de andre controllers skal opdateres, og hvornår vores
\textit{View} bliver opdateret.
% subsection Controller (end)

\subsection{Ændringer}\label{sub:Ændringer} % (fold)
Under udviklingsprocessen har vi valgt at arbejde i iterationer. Dette skal forstås i den forstand, at vi først designede implementeringer via. UML-digrammer, derefter implementerede disse designs, hvorefter vi konkluderede på, om hvorvidt vores kodebase overholdte de ønskede designprincipper (\textit{SOLID}). Denne process mundede ud i flere refaktoreringsprocesser, som havde til formål, at rette op på eventuelle brud på netop disse principper. 
Efter hver refaktorisering påbegyndte vi selvsamme udviklingsprocess, indtil nuværende stadie af spillet.
Disse refaktoriseringer, ændrede naturligvis også på klassernes afhængigheder mm., hvilket derfor også krævede tilpasning af UML-diagrammet. 
Et eksempel på refaktorisering i denne procces er, at vi i starten, blott havde sat \code{View}-klassen til at have alt ansvaret for at tegne objeketer på skærmen, samt at \code{Controller} havde ansvaret for at tage imod input fra brugeren og styre PacMan. Resten af spillets logik i denne iteration af udviklingsprocessen lå i \code{Maze}. Dette bryder \textit{SRP}, som derfor krævede refaktorisering inden viderudvilking.


\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.95\textwidth]{figures/UML-diagram-old.png}
    \end{center}
    \caption{Det første UML-diagram til projektet.}
    \label{UML-diagram-old}
\end{figure}
I et forsøg på at simplificerer \class{Maze} delte vi den op, og lavede en
\class{Game} klasse, hvis formål var at repræsenterer spillet. På denne måde
kunne \class{Controller} stå for at håndterer alt logikken, som også er mere
typisk af en \textit{Controller} at gøre i \textit{MVC}-modellen. Med denne
ændring ville maze bare stå for at repræsenterer labyrinten. UML-diagrammet for
denne forbedring kan ses på \autoref{UML-diagram-old2}.

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=0.95\textwidth]{figures/UML-diagram-old2.png}
    \end{center}
    \caption{Det andet UML-diagram til projektet.}
    \label{UML-diagram-old2}
\end{figure}
Siden da har vi udvidet endnu mere på projektet, og det ser nu ud som det gør på
\autoref{UML-diagram}.
% subsection Ændringer (end)

%\begin{itemize}
%  \item Inkludér et UML-diagram og en beskrivelse af jeres design.
  %\item Giv en kort beskrivelse af jeres diagram:
  %\begin{itemize}
  %  \item Hvad er de forskellige dele?
  %  \item Har I anvendt designmønstre i jeres design? I så fald, hvor i
  %  diagrammet findes disse? Det er ikke et krav at anvende designmøUML-diagram til \textit{Controller} delen af projektet.nstre, men
  %  kan være en god idé.
  %\end{itemize}
  %\item Dokumentér designbeslutninger hvor I har anvendt SOLID, DRY, eller andre
  %OO-principper. 
%  \item Hvis I i løbet af projektet har forfinet jeres design,
%  giv da en kort beskrivelse af hvilke ændringer I har foretaget og hvorfor.
%\end{itemize}
% section design (end)

\section{Implementation}\label{sec:Implementation} % (fold)

States

% \subsection{Moveable}\label{sub:Moveable} % (fold)
% Som nævnt i design sektionen har vi lavet en \code{Moveable} klasse. Det smarte
% ved den er at vi bare kan kalde metoden \code{move()} på en movable, og så
% bevæger den sig i den retning den har fået tildelt. 
% subsection Moveable (end)

\subsection{PacMan kontrol}\label{sub:PacMan Kontrol} % (fold)
Siden vi har gjort at en \textit{Moveable}'s position er beskrevet med decimal
tal, så skal der noget smart logik til for at PacMan kan bevæge sig "smooth"
omkring hjørner i labyrinten, da den består af en masse væge på
heltals-positioner, og PacMan er samme størrelse som væggene, så han passer kun
lige akurat imellem dem.

Idéen er at man kigger frem foran PacMan for at se om der er en passage til den
side man gerne vil hen, indikeret med et tastetryk. Hvis der er en passage
venter controlleren med at dreje PacMan indtil han er lige ved siden af
passagen. Dette har vi gjort ved at gemme retningn i et felt kaldet for
\code{waitingDirection}, og så hver gang \class{PacManController}'s
\code{update()} metode bliver kaldt, så tjekker den om PacMan's position er en
heltalsværdi. Det må nemlig betyde at han nu står foran den passage som der
tidligere blev set. I så fald drejer PacMan nu til retningen af
\code{waitingDirection}. 

Der er også casen hvor PacMan skifter retning til det modsatte af hvad han
bevæger sig. Så kan vi ikke kigge efter en passage der, for det vil der altid
være, og han vil dermed ikke skifte retning med det samme. Så i dette tilfælde
skifter vi bare retning med det samme. Hvis det er sådan at PacMan står stille,
så er vi ikke interreseret i at kigge efter en passage, og han skal bare bevæge
sig i den retning som man trykker med det samme.

For at lave alt dette med retninger, lavede vi en \code{enum} klasse til at
holde styr på de fire retninger vi tillader: op, ned, højre og venstre. For at
finde ud af hvilken en af disse retninger vores tastetryk svarer til, lavede vi
også en \class{DirectionAdapter} klasse, som står for at konverterer imellem
\class{Direction} og andre representationer af en retning.
% subsection PacMan Kontrol (end)

\subsection{Ghost AI}\label{sub:Ghost AI} % (fold)
\textbf{Søge Strategier}
Vi valgte at implementere forskellige måder for spøgelserne i PacMan til at jage PacMan(spilleren). 
Som vores primære metoder valgte vi to kendte søgealgoritmer, nemlig \textit{DepthFirstSearch} \& \textit{BreadthFirstSearch}. 
Vores grund for at bruge to søgealgoritmer og ikke kun en, var for at sikre lidt udforudselighed i spillet, 
da spøgelserne så skulle tage forskellige ruter mod PacMan.

\textbf{Node klassen}
For at kunne skabe fundamentet for at behandle vores Maze som et binært træ skabte vi klassen Node. 
Node objektet består af en forældre node, en arrayliste af noder som er dets børn og en Pos2D som er nodens position i Maze. 
Det første Node objekt ville være roden og have ingen forældre og ingen børn til at starte med, 
men den ville skulle have en start position(Pos2D).

Metoderne i Node klassen som gav gavn til os senere var addChild(), og setParent() som gjorde os i stand til at opdatere vores binære træ. 

\textbf{SearchAlgorithm grænsefladen} 
Grænsefladen SearchAlgorithm var ment som en måde at kunne give metoder til vores Abstrakte klasse AbstracSearchAlgorithm. 
De metoder vi valgte at give videre var to setters, setGoal() \& setStart(), samt en metode search() og en getter getMoveStack(). 
Metoden getMoveStack() er vores metode for at hente den sti af Pos2D spøgelserne skal gå for at nå PacMans position. 
Metoden search() ville blive brugt som en måde at søge efter et mål med den valgte søge strategi. 

\textbf{AbstractSearchAlgorithm abstrakt klasse}
Vores plan med AbstractSearchAlgorithm som en abstrakt klasse var, så kunne vi bruge AbstractSearchAlgorithm som skabelon for andre søgealgoritmer, og implementere SearchAlgorithm grænsefladen for at abstrahere de muligheder, de kommende søgealgoritmer skal have. Vi følte, at det var en god idé at limitere metoderne tilgængelige for de kommende søgealgoritmer for at undgå unødvendig komplesiktet og uforudselighed. 

En metode fra AbstractSearchAlgorithm som er essentiel for søgealgoritmen var vores metode getNeighbours(). Den er essentiel fordi den bruges til at undersøge de fire mulige bevægelser til rådighed(op, ned, højre, venstre) ud fra nuværende position. Ved brug af en \textit{for-løkke}, en \textit{boolean} metode IsWallAt() fra Pos2D klassen og to lokale \textit{Integer} variabler kan vi så sikre, at spøgelsernes nye positioner er lovlige(der er ikke en væg) og heller ikke uden for Mazen.

\textbf{DepthFirstSearch klasse }
I Depth-First Search er strategien at traversere et binært træ ved at søge første venstre gren i træet og fortsætte til målet nås. 
Hvis målet ikke nås i første søgning og vi istedet når bunden af træet, så \textit{backtracker} vi fra efterkommer noden op mod roden og udforsker de forskellige efterkommeres grene for at finde målet der. 
Hvis målet ikke findes returneres fejl.

For at implementere Depth-First Search brugte vi pseudokoden fra wikipedia(INSERT KILDEHENVISNING HERE) og oversatte den til vores program. 
For at kunne bruge metoden getNeighbours() fra abstrakt klassen, skal DepthFirstSearch klassen have adgang til vores Maze i DepthFirstSearch konstruktøren. 
Ved at følge pseudokoden, getNeighbours() og to metoder fra Node klassen undersøgte vi stier af Pos2D til PacMan, og returnerede en Stack af bevægelser som kunne gives til GhostController og updatere spøgelserne med update() metoden fra GhostController. 

En anden ændring er ved Stacks medfødte metode contains(). 
Når man i Stack vil undersøge om en Stack har objektet man spørger efter, kaldes contains() der bruges som en boolean til at sammenligne et objekt med objekterne i Stacken. 
Den metode har vi måtte override og ændre for at passe til Pos2D objektet. 
Ændringen er en \textit{for-løkke} der sammenligner Pos2D'ers X og Y værdier.

\textbf{Breadth-FirstSearch klasse} 
I Breadth-FirstSearch er strategien at traversere et binært træ ved at søge først venstre gren og så hver gren i et binært træ (i samme dybde). 
Vi går derefter først dybere i træet når hver gren er undersøgt. Hvis målet ikke findes returneres fejl.\\

For at implementere Breadth-First Search brugte vi pseudokoden fra wikipedia(INSERT KILDEHENVSNING HERE) og oversatte den til vores program. 
For at kunne bruge metoden getNeighbours() fra abstrakt klassen, skal BreadthFirstSearch klassen have adgang til vores Maze i BreadthFirstSearch konstruktøren. 
Ved at følge pseudokoden, getNeighbours() og to metoder fra Node klassen undersøgte vi stier af Pos2D til PacMan, 
og returnerede en Stack af bevægelser som kunne gives til GhostController og updatere spøgelserne med update() metoden fra GhostController. 
Da vi brugte lænkede lister som vores kø i BreadthFirstSearch, 
og lænkede lister i Java også har metoden contains(),  valgte vi at Override contains() og ændre den for samme grunde og på samme vis som i DepthFirstSearch klassen.

% subsection Ghost AI (end)

\subsection{Animationer}\label{sub:Animationer} % (fold)
Da vi gerne ville have animationer i spillet, lavede vi en klasse kaldet
\class{AnimatedImage}, som står for at repræsenterer de forskellige frames af en
animation, indlæse frames fra en sti, og ændre farver i dem hvis der er brug for
det. Det med at ændre farver har vi gjort så vi ikke selv skal tegne et nyt set
frames for hvert spøgelse vi vil lave i en anden farve, men i stedet for kan
lave ét set med en meget specifik farve (hvis hex værdi er \#000001), og så
udskifte den farve med farven af spøgelset.

Når man så laver et nyt \class{AnimatedImage}, så specificerer man hvor lang tid
én frame varer i nanosekunder. På denne måde kan vi i \code{getFrame()} metode
regne ud hvilken frame vi giver, ud fra den nuværende tid som metoden for. Det
gør den ved først at regne ud hvor lang tid hele animationen tager. Derefter
finder vi hvor langt inde i den animation cyklus vi er ved at tage den
nuværende tid modulus længden af animationen. Med dette kan vi så dividerer med
længden af én frame og få det frame indeks som vi er nået til.

For at farve spøgelsernes animationerne de rigtige farver benytter vi vores
metode \code{replaceColorsInFrames()}, som udskifter alle farver som er lig med
\code{fromColor} i en animations frames, og sætter dem til farven
\code{toColor}. Dette gør den ved at gå igennem hver frame pixelvis og tjekke om
de matcher \code{fromColor}, for så at udskifte det med \code{toColor} på en
kopi af framet, så det til sidst kan blive overskrevet.
% subsection Animationer (end)

\subsection{Afstande \& Algebra}
For at en \class{Moveable} og en \class{Pos2D} selv skal stå for at udregne en
afstand til andre objekter, så har vi lavet en klasse \class{Algebra} som står
for netop dette. Det ville nemlig bryde \textit{SRP}, hvis en klasse der kun
står for at repræsenterer en position, også skulle stå for at udregne afstanden
mellem positioner.

\subsection{Maze}
Til formålet for at lave labyrinten til spillet, skulle vi have en måde hvorpå
det var nemt at ændre i den, og bygge den op. Derfor lavede vi den som en tekst
fil. For så at læse denne tekst fil, og finde de forskellige elementer i den,
har lavede vi en klasse \class{TextualMaze}. Dens formål er kun at læse indholdet
af filen, of finde positionerne af alt i filen, ved brug af metode
\code{locateCharacter()}.

Udover dette har vi også lavet en klasse \class{Maze} som kun holder alle
væggene. På denne måde står \class{Maze} ikke selv for at læse en tekstfil og
kigge rundt i den. På denne måde benytter vi også \textit{SRP}.

\begin{itemize}
  \item Formålet med denne rapportsektion er at give den interesserede læser et
  overblik over de interessante implementationsdetaljer, som er værd at kigge
  nærmere på i jeres kodebase, samt nødvendige detaljer for at køre jeres kode.
  \item angiv hvilken version af java i har brugt til at teste og kompilere
  jeres kode, og inkludérkorte instruktioner til hvordan man kompilerer og kører
  koden.
  \item giv en beskrivelse på højniveau af interessante implementationsaspekter.
  F.eks., aspekter, I har brugt særligt meget tid eller energi på.
  \item Det kunne f.eks. være mere avancerede aspekter såsom hvordan I håndterer
  AI, hvordan I håndterer spilhandlinger, animation, eller andet.
  \item Hold beskrivelsen overordnet. Vi kan læse jeres kode for detaljerne.
\end{itemize}
% section Implementation (end)

\newpage
\section{Kvalitetssikring}\label{sec:Kvalitetssikring} % (fold)
Til fordel for at sikre, at vores kode/program/spil lever op til
kravsspecifikationen (se \autoref{sec:design}), har vi valgt at anvende
unit-tests. Unit-testing defineres i denne kontekst som test af enkelte
komponenter af programmet, som til sammen skaber det ønskede overblik.

I overenstemmelse med vores valg af unit-tests, er det også underforstået, at vi
tester i en form for white-box testing. Med dette betyder det, at dem der
skriver testsne (os som udviklere af spillet i dette tilfælde), kender til alt
logikken bag implementeringen. Med dette, har man som "\textit{tester}", altså
mulighed for at tjekke, om en given invariant for en given metode overholdes
under kørsel.

Mere specifikt; har vi valgt at benytte os af \textit{Java}s framework
\code{JUnit}, som b.la. understøtter behjælpelige sammenligningsmetoder (f.eks.
\textit{assertions} via \code{assert}).

Med dette, anvender vi altså også unit-testing som middel til at krydstjekke med
vores kravsspecifikation, om disse (krav) samt eventuelle invarianter er
overholdt.

Med anvendelse af ovennævnte, kan fejfindingprocessen under udviklingen, i nogle
tilfælde, forkortes markant. Man kan med andre ord, nogle gange, såfremt man
skriver tilstrækkelige unit-tests, forsimple samt forbedre design og
udviklingsprocessen.

Ydermere, har vi til håndtering af versionsstyring anvendt \code{git} i form af
nye branches under udvikling af nye programfunktionaliteter. Dette konstruerer
en form for automatiseret testing, da man ikke kan publicere ny funktionalitet,
før det passer med den resterende kodebase (f.eks. håndtering af mergeconflicts
mm.). Denne form for \textit{automatiseret} testing er også kendt som
\textit{Continuous integration testing}. I det følgende, kan man se hvorledes sådanne en unit-test kunne se ud.

Det kan eksempelvis være behjælpeligt at være sikker på, at ens metoder som er konstrueret til at beregne distancen mellem objecter, rent faktisk returnerer ønskede værdier. For at sikre os, at vores adhoc polymorfiske metode \code{distanceBetween}, overholder dette, har vi valgt at konstruere følgende unit-test:
\snippet{12}{55}{./code/AlgebraTest.java}

Man kunne derudover også have valgt at lave en form for black-box-testing hvorved individer som ikke kender til kode-basen f.eks. prøver at spille spillet og derved rapportere evt. fejl (både visuelle og logiske).
% \begin{itemize}
%   \item Beskriv hvordan I har testet, at jeres kode lever op til
%   kravsspecifikationen. Har I, f.eks., benyttet unit tests? Manuelle tests?
%   \item Ville I have taget en anden tilgang til kvalitetssikring hvis I skulle
%   designe og implementere projektet forfra?
% \end{itemize}
% section Kvalitetssikring (end)

\section{Proces}\label{sec:Proces} % (fold)
\begin{itemize}
  \item Arbejdede I i faser i løbet af projektet?
  \item Hvordan gik samarbejdet, og hvordan sikrede I lige deltagelse?
  \item Brugte I tekniske værktøjer til at få samarbejdet til at glide nemmere
  på tværs af maskiner?
  \item Har I brugt AI som støtte under udviklingen af jeres projekt? I så fald,
  hvordan?
\end{itemize}
% section Proces (end)

\section{Diskussion}\label{sec:Diskussion} % (fold)
\begin{itemize}
  \item Ville I gøre noget anderledes hvis I skulle implementere projektet
  forfra?
  \item Var der dele af projektbeskrivelsen I ikke nåede? I så fald, hvordan er
  disse dele kompatible med jeres design? Ville I foretage ændringer for at
  imødekomme ændringer?
\end{itemize}
% section Diskussion (en

\end{document}
